#!/usr/bin/env python3
from __future__ import annotations

import argparse
import hashlib
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable


def _norm_name(name: str) -> str:
    return "".join(str(name).lower().split())


def _classify_stl(p: Path) -> str | None:
    n = _norm_name(p.name)
    if n.endswith(".stl"):
        n = n[:-4]
    if "upperjawscan" in n:
        return "upper"
    if "lowerjawscan" in n:
        return "lower"
    if "bitescan" in n:
        return "bite"
    return None


def _sha1_hex(text: str) -> str:
    return hashlib.sha1(text.encode("utf-8")).hexdigest()


@dataclass(frozen=True)
class _Candidate:
    relpath: str
    bytes: int
    mtime: float


def _iter_stl_files(root: Path) -> Iterable[Path]:
    # Keep scan bounded to STL files only (fast enough for ~1k files).
    yield from root.rglob("*.stl")
    yield from root.rglob("*.STL")


def _pick_candidates(paths: list[Path], *, root: Path, store_paths: str) -> list[_Candidate]:
    out: list[_Candidate] = []
    for p in paths:
        try:
            st = p.stat()
        except FileNotFoundError:
            continue
        rel = str(p if store_paths == "absolute" else p.relative_to(root)).replace("\\", "/")
        out.append(_Candidate(relpath=rel, bytes=int(st.st_size), mtime=float(st.st_mtime)))
    out.sort(key=lambda c: (-c.bytes, c.relpath))
    return out


def _has_any_ext(dir_path: Path, exts: set[str], *, max_hits: int = 1) -> bool:
    hits = 0
    for p in dir_path.rglob("*"):
        if not p.is_file():
            continue
        if p.suffix.lower() in exts:
            hits += 1
            if hits >= max_hits:
                return True
    return False


def _find_preview_images(dir_path: Path, *, root: Path, store_paths: str, limit: int = 16) -> list[_Candidate]:
    candidates: list[Path] = []
    for p in dir_path.rglob("*"):
        if not p.is_file():
            continue
        suf = p.suffix.lower()
        if suf not in {".png", ".jpg", ".jpeg"}:
            continue
        name = _norm_name(p.name)
        if "autogeneratedimages.models" in name:
            candidates.append(p)
        elif name in {"sideview.png", "front.png", "left.png", "right.png"}:
            candidates.append(p)
    cand = _pick_candidates(candidates, root=root, store_paths=store_paths)
    return cand[:limit]


def main() -> None:
    ap = argparse.ArgumentParser(description="Index intraoral STL cases (local-only).")
    ap.add_argument(
        "--root",
        type=Path,
        default=Path("downloads/体内数据库/体内数据库"),
        help="Root folder of the intraoral database.",
    )
    ap.add_argument(
        "--out",
        type=Path,
        default=Path("metadata/internal_db/index.jsonl"),
        help="Output JSONL path (should be gitignored).",
    )
    ap.add_argument("--limit", type=int, default=0, help="Limit number of cases (0 = no limit).")
    ap.add_argument(
        "--store-paths",
        type=str,
        default="relative",
        choices=["relative", "absolute"],
        help="Store file paths as relative-to-root (recommended) or absolute paths.",
    )
    ap.add_argument(
        "--no-anonymize",
        action="store_true",
        help="Use directory name as display_name (may contain PII).",
    )
    args = ap.parse_args()

    root = args.root.expanduser().resolve()
    if not root.exists():
        raise SystemExit(f"Root not found: {root}")
    if not root.is_dir():
        raise SystemExit(f"Root is not a directory: {root}")

    # Group STL assets by their parent directory.
    by_dir: dict[Path, dict[str, list[Path]]] = {}
    for stl in _iter_stl_files(root):
        if not stl.is_file():
            continue
        group_dir = stl.parent
        d = by_dir.setdefault(group_dir, {"upper": [], "lower": [], "bite": [], "other": []})
        kind = _classify_stl(stl)
        if kind in {"upper", "lower", "bite"}:
            d[kind].append(stl)
        else:
            d["other"].append(stl)

    records: list[dict] = []
    for group_dir, paths in by_dir.items():
        if not (paths["upper"] or paths["lower"] or paths["bite"]):
            continue

        rel_group = str(group_dir.relative_to(root)).replace("\\", "/")
        upper = _pick_candidates(paths["upper"], root=root, store_paths=args.store_paths)
        lower = _pick_candidates(paths["lower"], root=root, store_paths=args.store_paths)
        bite = _pick_candidates(paths["bite"], root=root, store_paths=args.store_paths)
        other = _pick_candidates(paths["other"], root=root, store_paths=args.store_paths)

        mtime_max = 0.0
        for c in [*upper, *lower, *bite]:
            mtime_max = max(mtime_max, c.mtime)

        # Stable UID derived from directory + (relpath,size) of primary STL candidates.
        uid_src = {
            "dir": rel_group,
            "upper": [(c.relpath, c.bytes) for c in upper],
            "lower": [(c.relpath, c.bytes) for c in lower],
            "bite": [(c.relpath, c.bytes) for c in bite],
        }
        case_uid = _sha1_hex(json.dumps(uid_src, ensure_ascii=False, sort_keys=True))
        display_name = group_dir.name if args.no_anonymize else f"case_{case_uid[:8]}"

        preview_images = _find_preview_images(group_dir, root=root, store_paths=args.store_paths)
        has_dicom = _has_any_ext(group_dir, {".dcm"}, max_hits=1)

        record = {
            "version": "1.0",
            "case_uid": case_uid,
            "source_relpath": rel_group,
            "display_name": display_name,
            "mtime_max": mtime_max,
            "has_dicom": bool(has_dicom),
            "assets": {
                "upper_stl": {
                    "best": (upper[0].__dict__ if upper else None),
                    "candidates": [c.__dict__ for c in upper],
                },
                "lower_stl": {
                    "best": (lower[0].__dict__ if lower else None),
                    "candidates": [c.__dict__ for c in lower],
                },
                "bite_stl": {
                    "best": (bite[0].__dict__ if bite else None),
                    "candidates": [c.__dict__ for c in bite],
                },
                "other_stl": [c.__dict__ for c in other],
            },
            "preview_images": [c.__dict__ for c in preview_images],
        }
        records.append(record)

    records.sort(key=lambda r: (-float(r.get("mtime_max", 0.0)), str(r.get("case_uid", ""))))
    if args.limit and args.limit > 0:
        records = records[: int(args.limit)]

    args.out.parent.mkdir(parents=True, exist_ok=True)
    with args.out.open("w", encoding="utf-8") as f:
        for r in records:
            f.write(json.dumps(r, ensure_ascii=False) + "\n")

    print(f"Wrote {len(records)} cases to {args.out}")


if __name__ == "__main__":
    main()

